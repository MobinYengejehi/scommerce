package dbsamples

import (
	"context"
	"encoding/json"
	"errors"

	"github.com/MobinYengejehi/scommerce/scommerce"

	"github.com/jackc/pgx/v5/pgtype"
)

var _ scommerce.DBProductManager[UserAccountID] = &PostgreDatabase{}

func (db *PostgreDatabase) newProductCategory(id pgtype.Int8, fs scommerce.FileStorage) *scommerce.BuiltinProductCategory[UserAccountID] {
	var parentCat *scommerce.BuiltinProductCategory[UserAccountID] = nil
	if id.Valid {
		parentCat = &scommerce.BuiltinProductCategory[UserAccountID]{
			DB: db,
			FS: fs,
			ProductCategoryForm: scommerce.ProductCategoryForm[UserAccountID]{
				ID: uint64(id.Int64),
			},
		}
	}
	return parentCat
}

func (db *PostgreDatabase) getSafeImages(images []string) *[]string {
	if images == nil {
		return nil
	}
	return &images
}

func (db *PostgreDatabase) GetProductCategories(ctx context.Context, categories []uint64, catForms []*scommerce.ProductCategoryForm[UserAccountID], skip int64, limit int64, queueOrder scommerce.QueueOrder, fs scommerce.FileStorage) ([]uint64, []*scommerce.ProductCategoryForm[UserAccountID], error) {
	ids := categories
	if ids == nil {
		ids = make([]uint64, 0, 10)
	}
	forms := catForms
	if forms == nil {
		forms = make([]*scommerce.ProductCategoryForm[UserAccountID], 0, cap(ids))
	}

	rows, err := db.PgxPool.Query(
		ctx,
		`select "id", "name", "parent_category_id" from product_categories order by "id" `+queueOrder.String()+` offset $1 limit $2`,
		skip,
		limit,
	)
	if err != nil {
		return nil, nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var id uint64
		var name string
		var parentCategoryID pgtype.Int8
		if err := rows.Scan(&id, &name, &parentCategoryID); err != nil {
			return nil, nil, err
		}
		ids = append(ids, id)
		forms = append(forms, &scommerce.ProductCategoryForm[UserAccountID]{
			ID:                    id,
			Name:                  &name,
			ParentProductCategory: db.newProductCategory(parentCategoryID, fs),
		})
	}

	if err := rows.Err(); err != nil {
		return nil, nil, err
	}

	return ids, forms, nil
}

func (db *PostgreDatabase) GetProductCategoryCount(ctx context.Context) (uint64, error) {
	var count uint64 = 0
	err := db.PgxPool.QueryRow(
		ctx,
		`select count("id") from product_categories`,
	).Scan(&count)
	if err != nil {
		return 0, err
	}
	return count, nil
}

func (db *PostgreDatabase) InitProductManager(ctx context.Context) error {
	_, err := db.PgxPool.Exec(
		ctx,
		`
			create table if not exists product_categories(
				id                 bigint generated by default as identity primary key,
				name               varchar(256) not null,
				parent_category_id bigint references product_categories(id)
			);

			create table if not exists products(
				id             bigint generated by default as identity primary key,
				name           varchar(256) not null,
				description    text,
				product_images jsonb,
				category_id    bigint references product_categories(id)
			);

			create table if not exists product_items(
				id                bigint generated by default as identity primary key,
				sku               varchar(256) unique,
				name              varchar(256) not null,
				price             double precision default 0,
				quantity_in_stock integer not null default 0,
				attributes        jsonb,
				product_images    jsonb,
				product_id        bigint references products(id)
			);

			create index if not exists product_items_product_idx on product_items(product_id);

			create or replace function search_product_categories(
				search_term_arg varchar,
				deepsearch_arg  bool,
				skip_arg        bigint,
				limit_arg       bigint,
				queue_order_arg varchar
			) returns table (
				id                 bigint,
				name               varchar(256),
				parent_category_id bigint
			) as $$
			begin
				return query
					execute format(
						'
							select
								p.id,
								p.name,
								p.parent_category_id
							from product_categories p
							where %s
							order by p.name %s
							offset $2
							limit $3
						',
						case
							when search_term_arg = '*****' then
								'true'
							when deepsearch_arg then
								'(p.name = $1)'
							else
								'(p.name ilike ''%%'' || $1 || ''%%'')'
						end,
						case
							when lower(queue_order_arg) = 'desc' then
								'desc'
							else
								'asc'
						end
					) using search_term_arg, skip_arg, limit_arg;
			end;
			$$ language plpgsql;

			create or replace function search_products(
				search_term_arg varchar,
				deepsearch_arg  bool,
				skip_arg        bigint,
				limit_arg       bigint,
				queue_order_arg varchar,
				category_id_arg bigint default null
			) returns table (
				id             bigint,
				name           varchar(256),
				description    text,
				product_images jsonb,
				category_id    bigint
			) as $$
			begin
				return query
					execute format(
						'
							select
								p.id,
								p.name,
								p.description,
								p.product_images,
								p.category_id
							from products p
							where %s
							%s
							order by p.name %s
							offset $2
							limit $3
						',
						case
							when search_term_arg = '*****' then
								'true'
							when deepsearch_arg then
								'(p.name = $1 or p.description = $1)'
							else
								'(p.name ilike ''%%'' || $1 || ''%%'' or p.description ilike ''%%'' || $1 || ''%%'')'
						end,
						case
							when category_id_arg is not null then
								'and p.category_id = ' || category_id_arg::text
							else
								''
						end,
						case
							when lower(queue_order_arg) = 'desc' then
								'desc'
							else
								'asc'
						end
					) using search_term_arg, skip_arg, limit_arg;
			end;
			$$ language plpgsql;

			create or replace function search_product_items(
				search_term_arg varchar,
				deepsearch_arg  bool,
				skip_arg        bigint,
				limit_arg       bigint,
				queue_order_arg varchar,
				product_id_arg  bigint default null,
				category_id_arg bigint default null
			) returns table(
				item_id             bigint,
				sku                 varchar(256),
				item_name           varchar(256),
				price               double precision,
				quantity_in_stock   integer,
				attributes          jsonb,
				item_images         jsonb,
				product_id          bigint,
				product_name        varchar(256),
				product_description text,
				category_id         bigint,
				category_name       varchar(256)
			) as $$
			begin
				return query
					execute format(
						'
							select
								pi.id as item_id,
								pi.sku,
								pi.name as item_name,
								pi.price,
								pi.quantity_in_stock as quantity_in_stock,
								pi.attributes,
								pi.product_images as item_images,
								p.id as product_id,
								p.name as product_name,
								p.description as product_description,
								pc.id as category_id,
								pc.name as category_name
							from product_items pi
							inner join products p on pi.product_id = p.id
							left join product_categories pc on p.category_id = pc.id
							where %s
							%s
							%s
							order by p.name %s, pi.sku %s
							offset $2
							limit $3
						',
						case
							when search_term_arg = '*****' then
								'true'
							when deepsearch_arg then
								'(pi.name = $1 or p.name = $1 or p.description = $1 or pi.sku = $1)'
							else
								'(pi.name ilike ''%%'' || $1 || ''%%'' or p.name ilike ''%%'' || $1 || ''%%'' or p.description ilike ''%%'' || $1 || ''%%'' or pi.sku ilike ''%%'' || $1 || ''%%'')'
						end,
						case
							when product_id_arg is not null then
								'and p.id = ' || product_id_arg::text
							else
								''
						end,
						case
							when category_id_arg is not null then
								'and pc.id = ' || category_id_arg::text
							else
								''
						end,
						case
							when lower(queue_order_arg) = 'desc' then
								'desc'
							else
								'asc'
						end,
						case
							when lower(queue_order_arg) = 'desc' then
								'desc'
							else
								'asc'
						end
					) using search_term_arg, skip_arg, limit_arg;
			end;
			$$ language plpgsql;
		`,
	)
	return err
}

func (db *PostgreDatabase) NewProductCategory(ctx context.Context, name string, parentCategory *uint64, catForm *scommerce.ProductCategoryForm[UserAccountID], fs scommerce.FileStorage) (uint64, error) {
	var id uint64
	var rName string
	var parentCategoryID pgtype.Int8
	err := db.PgxPool.QueryRow(
		ctx,
		`insert into product_categories("name", "parent_category_id") values($1, $2) returning "id", "name", "parent_category_id"`,
		name,
		parentCategory,
	).Scan(&id, &rName, &parentCategoryID)
	if err != nil {
		return 0, err
	}
	if catForm != nil {
		catForm.ID = id
		catForm.Name = &rName
		catForm.ParentProductCategory = db.newProductCategory(parentCategoryID, fs)
	}
	return id, err
}

func (db *PostgreDatabase) RemoveAllProductCategories(ctx context.Context) error {
	_, err := db.PgxPool.Exec(
		ctx,
		`delete from product_categories`,
	)
	return err
}

func (db *PostgreDatabase) RemoveProductCategory(ctx context.Context, category uint64) error {
	_, err := db.PgxPool.Exec(
		ctx,
		`delete from product_categories where "id" = $1`,
		category,
	)
	return err
}

func (db *PostgreDatabase) SearchForProductCategories(ctx context.Context, searchText string, deepSearch bool, categories []uint64, catForms []*scommerce.ProductCategoryForm[UserAccountID], skip int64, limit int64, queueOrder scommerce.QueueOrder, fs scommerce.FileStorage) ([]uint64, []*scommerce.ProductCategoryForm[UserAccountID], error) {
	ids := categories
	if ids == nil {
		ids = make([]uint64, 0, 10)
	}
	forms := catForms
	if forms == nil {
		forms = make([]*scommerce.ProductCategoryForm[UserAccountID], 0, cap(ids))
	}

	rows, err := db.PgxPool.Query(
		ctx,
		`select "id", "name", "parent_category_id" from search_product_categories($1, $2, $3, $4, $5)`,
		searchText,
		deepSearch,
		skip,
		limit,
		queueOrder,
	)
	if err != nil {
		return nil, nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var id uint64
		var name string
		var parentCategoryID pgtype.Int8
		if err := rows.Scan(&id, &name, &parentCategoryID); err != nil {
			return nil, nil, err
		}
		ids = append(ids, id)
		forms = append(forms, &scommerce.ProductCategoryForm[UserAccountID]{
			ID:                    id,
			Name:                  &name,
			ParentProductCategory: db.newProductCategory(parentCategoryID, fs),
		})
	}

	if err := rows.Err(); err != nil {
		return nil, nil, err
	}

	return ids, forms, nil
}

func (db *PostgreDatabase) SearchForProductItems(ctx context.Context, searchText string, deepSearch bool, items []uint64, itemForms []*scommerce.ProductItemForm[UserAccountID], skip int64, limit int64, queueOrder scommerce.QueueOrder, product *uint64, category *uint64, fs scommerce.FileStorage) ([]uint64, []*scommerce.ProductItemForm[UserAccountID], error) {
	ids := items
	if ids == nil {
		ids = make([]uint64, 0, 10)
	}
	forms := itemForms
	if forms == nil {
		forms = make([]*scommerce.ProductItemForm[UserAccountID], 0, cap(ids))
	}

	rows, err := db.PgxPool.Query(
		ctx,
		`
			select
				"item_id",
				"sku",
				"item_name",
				"price",
				"quantity_in_stock",
				"attributes",
				"item_images",
				"product_id",
				"product_name",
				"product_description",
				"category_id",
				"category_name"
			from search_product_items($1, $2, $3, $4, $5, $6, $7)`,
		searchText,
		deepSearch,
		skip,
		limit,
		queueOrder,
		product,
		category,
	)
	if err != nil {
		return nil, nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var id uint64
		var sku string
		var name string
		var price float64
		var quantityInStock int32
		var attributes json.RawMessage
		var itemImages json.RawMessage
		var productID pgtype.Int8
		var productName string
		var productDesc pgtype.Text
		var categoryID pgtype.Int8
		var categoryName pgtype.Text
		if err := rows.Scan(
			&id,
			&sku,
			&name,
			&price,
			&quantityInStock,
			&attributes,
			&itemImages,
			&productID,
			&productName,
			&productDesc,
			&categoryID,
			&categoryName,
		); err != nil {
			return nil, nil, err
		}

		var images []string
		if err := json.Unmarshal(itemImages, &images); err != nil {
			return nil, nil, err
		}

		var quantity uint64 = uint64(quantityInStock)

		var productDescription string
		if productDesc.Valid {
			productDescription = productDesc.String
		}

		var product *scommerce.BuiltinProduct[UserAccountID] = nil
		if productID.Valid {
			var category *scommerce.BuiltinProductCategory[UserAccountID] = nil
			if categoryID.Valid {
				category = db.newProductCategory(categoryID, fs)
				if categoryName.Valid {
					category.Name = &categoryName.String
				}
			}
			product = &scommerce.BuiltinProduct[UserAccountID]{
				DB: db,
				FS: fs,
				ProductForm: scommerce.ProductForm[UserAccountID]{
					ID:              uint64(productID.Int64),
					Description:     &productDescription,
					Name:            &productName,
					ProductCategory: category,
				},
			}
		}

		ids = append(ids, id)
		forms = append(forms, &scommerce.ProductItemForm[UserAccountID]{
			ID:              id,
			Attributes:      &attributes,
			Images:          db.getSafeImages(images),
			Price:           &price,
			Name:            &name,
			QuantityInStock: &quantity,
			SKU:             &sku,
			Product:         product,
		})
	}

	if err := rows.Err(); err != nil {
		return nil, nil, err
	}

	return ids, forms, nil
}

func (db *PostgreDatabase) SearchForProducts(ctx context.Context, searchText string, deepSearch bool, products []uint64, productForms []*scommerce.ProductForm[UserAccountID], skip int64, limit int64, queueOrder scommerce.QueueOrder, category *uint64, fs scommerce.FileStorage) ([]uint64, []*scommerce.ProductForm[UserAccountID], error) {
	ids := products
	if ids == nil {
		ids = make([]uint64, 0, 10)
	}
	forms := productForms
	if forms == nil {
		forms = make([]*scommerce.ProductForm[UserAccountID], 0, cap(ids))
	}

	rows, err := db.PgxPool.Query(
		ctx,
		`select "id", "name", "description", "product_images", "category_id" from search_products($1, $2, $3, $4, $5, $6)`,
		searchText,
		deepSearch,
		skip,
		limit,
		queueOrder,
		category,
	)
	if err != nil {
		return nil, nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var id uint64
		var name string
		var description pgtype.Text
		var productImages json.RawMessage
		var categoryId pgtype.Int8
		if err := rows.Scan(
			&id,
			&name,
			&description,
			&productImages,
			&categoryId,
		); err != nil {
			return nil, nil, err
		}

		var desc string
		if description.Valid {
			desc = description.String
		}

		var images []string
		if err := json.Unmarshal(productImages, &images); err != nil {
			return nil, nil, err
		}

		var category *scommerce.BuiltinProductCategory[UserAccountID] = nil
		if categoryId.Valid {
			category = db.newProductCategory(categoryId, fs)
		}

		ids = append(ids, id)
		forms = append(forms, &scommerce.ProductForm[UserAccountID]{
			ID:              id,
			Name:            &name,
			Description:     &desc,
			Images:          db.getSafeImages(images),
			ProductCategory: category,
		})
	}

	if err := rows.Err(); err != nil {
		return nil, nil, err
	}

	return ids, forms, nil
}

func (db *PostgreDatabase) FillProductCategoryWithID(ctx context.Context, cid uint64, catForm *scommerce.ProductCategoryForm[UserAccountID], fs scommerce.FileStorage) error {
	if catForm == nil {
		return errors.New("product category form is nil")
	}

	var name string
	var parentCategoryID pgtype.Int8

	err := db.PgxPool.QueryRow(
		ctx,
		`
			select
				"name",
				"parent_category_id"
			from product_categories
			where "id" = $1
			limit 1
		`,
		cid,
	).Scan(
		&name,
		&parentCategoryID,
	)
	if err != nil {
		return err
	}

	catForm.ID = cid
	catForm.Name = &name
	catForm.ParentProductCategory = db.newProductCategory(parentCategoryID, fs)

	return nil
}

func (db *PostgreDatabase) FillProductWithID(ctx context.Context, pid uint64, productForm *scommerce.ProductForm[UserAccountID], fs scommerce.FileStorage) error {
	if productForm == nil {
		return errors.New("product form is nil")
	}

	var name string
	var description pgtype.Text
	var productImages json.RawMessage
	var categoryID pgtype.Int8

	err := db.PgxPool.QueryRow(
		ctx,
		`
			select
				"name",
				"description",
				"product_images",
				"category_id"
			from products
			where "id" = $1
			limit 1
		`,
		pid,
	).Scan(
		&name,
		&description,
		&productImages,
		&categoryID,
	)
	if err != nil {
		return err
	}

	var images []string
	if productImages != nil {
		if err := json.Unmarshal(productImages, &images); err != nil {
			return err
		}
	}

	productForm.ID = pid
	productForm.Name = &name

	if description.Valid {
		productForm.Description = &description.String
	} else {
		productForm.Description = nil
	}

	productForm.Images = db.getSafeImages(images)

	if categoryID.Valid {
		productForm.ProductCategory = &scommerce.BuiltinProductCategory[UserAccountID]{
			DB: db,
			FS: fs,
			ProductCategoryForm: scommerce.ProductCategoryForm[UserAccountID]{
				ID: uint64(categoryID.Int64),
			},
		}
	} else {
		productForm.ProductCategory = nil
	}

	return nil
}

func (db *PostgreDatabase) FillProductItemWithID(ctx context.Context, iid uint64, itemForm *scommerce.ProductItemForm[UserAccountID], fs scommerce.FileStorage) error {
	if itemForm == nil {
		return errors.New("product item form is nil")
	}

	var sku string
	var name string
	var price float64
	var quantityInStock int32
	var attributes json.RawMessage
	var itemImages json.RawMessage
	var productID pgtype.Int8

	err := db.PgxPool.QueryRow(
		ctx,
		`
			select
				"sku",
				"name",
				"price",
				"quantity_in_stock",
				"attributes",
				"product_images",
				"product_id"
			from product_items
			where "id" = $1
			limit 1
		`,
		iid,
	).Scan(
		&sku,
		&name,
		&price,
		&quantityInStock,
		&attributes,
		&itemImages,
		&productID,
	)
	if err != nil {
		return err
	}

	var images []string
	if itemImages != nil {
		if err := json.Unmarshal(itemImages, &images); err != nil {
			return err
		}
	}

	quantity := uint64(quantityInStock)

	itemForm.ID = iid
	itemForm.SKU = &sku
	itemForm.Name = &name
	itemForm.Price = &price
	itemForm.QuantityInStock = &quantity
	itemForm.Attributes = &attributes
	itemForm.Images = db.getSafeImages(images)

	if productID.Valid {
		itemForm.Product = &scommerce.BuiltinProduct[UserAccountID]{
			DB: db,
			FS: fs,
			ProductForm: scommerce.ProductForm[UserAccountID]{
				ID: uint64(productID.Int64),
			},
		}
	} else {
		itemForm.Product = nil
	}

	return nil
}
