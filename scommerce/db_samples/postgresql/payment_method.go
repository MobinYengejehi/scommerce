package dbsamples

import (
	"context"
	"errors"
	"time"

	"github.com/MobinYengejehi/scommerce/scommerce"

	"github.com/jackc/pgx/v5/pgtype"
)

var _ scommerce.DBUserPaymentMethodManager[UserAccountID] = &PostgreDatabase{}
var _ scommerce.DBUserPaymentMethod[UserAccountID] = &PostgreDatabase{}

func (db *PostgreDatabase) GetUserPaymentMethodCount(ctx context.Context) (uint64, error) {
	var count uint64
	err := db.PgxPool.QueryRow(
		ctx,
		`select count("id") from payment_methods`,
	).Scan(&count)
	if err != nil {
		return 0, err
	}
	return count, nil
}

func (db *PostgreDatabase) GetUserPaymentMethods(ctx context.Context, methods []scommerce.DBUserPaymentMethodResult[UserAccountID], methodForms []*scommerce.UserPaymentMethodForm[UserAccountID], skip int64, limit int64, queueOrder scommerce.QueueOrder) ([]scommerce.DBUserPaymentMethodResult[UserAccountID], []*scommerce.UserPaymentMethodForm[UserAccountID], error) {
	ids := methods
	if ids == nil {
		ids = make([]scommerce.DBUserPaymentMethodResult[UserAccountID], 0, 10)
	}
	forms := methodForms
	if forms == nil {
		forms = make([]*scommerce.UserPaymentMethodForm[UserAccountID], 0, cap(ids))
	}

	rows, err := db.PgxPool.Query(
		ctx,
		`
			select
				"id",
				"user_id",
				"payment_type_id",
				"provider",
				"account_number",
				"expiry_date",
			 	"expiry_date" < current_date as "is_expired",
				"is_default"
			from payment_methods
			order by "id" `+queueOrder.String()+`
			offset $1
			limit $2
		`,
		skip,
		limit,
	)
	if err != nil {
		return nil, nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var id uint64
		var userID UserAccountID
		var paymentTypeID uint64
		var provider pgtype.Text
		var accountNumber pgtype.Text
		var expiryDate pgtype.Date
		var isExpired bool
		var isDefault bool
		if err := rows.Scan(
			&id,
			&userID,
			&paymentTypeID,
			&provider,
			&accountNumber,
			&expiryDate,
			&isExpired,
			&isDefault,
		); err != nil {
			return nil, nil, err
		}

		var date *time.Time
		if expiryDate.Valid {
			date = &expiryDate.Time
		}

		var prov *string
		if provider.Valid {
			prov = &provider.String
		}

		var accNum *string
		if accountNumber.Valid {
			accNum = &accountNumber.String
		}

		var paymentType *scommerce.BuiltinPaymentType = nil
		if paymentTypeID != 0 {
			paymentType = &scommerce.BuiltinPaymentType{
				DB: db,
				PaymentTypeForm: scommerce.PaymentTypeForm{
					ID: paymentTypeID,
				},
			}
		}

		ids = append(ids, scommerce.DBUserPaymentMethodResult[UserAccountID]{
			ID:  id,
			AID: userID,
		})
		forms = append(forms, &scommerce.UserPaymentMethodForm[UserAccountID]{
			ID:             id,
			UserAccountID:  userID,
			PaymentType:    paymentType,
			Provider:       prov,
			AccountNumber:  accNum,
			ExpiryDate:     date,
			IsExpiredState: &isExpired,
			IsDefaultState: &isDefault,
		})
	}

	if err := rows.Err(); err != nil {
		return nil, nil, err
	}

	return ids, forms, nil
}

func (db *PostgreDatabase) InitUserPaymentMethodManager(ctx context.Context) error {
	_, err := db.PgxPool.Exec(
		ctx,
		`
			create table if not exists payment_methods (
				id              bigint generated by default as identity primary key,
				user_id         bigint not null references users(id) on delete cascade,
				payment_type_id bigint not null references payment_types(id),
				provider        varchar(256),
				account_number  varchar(256),
				expiry_date     date,
				is_default      boolean not null default false
			);
		`,
	)
	return err
}

func (db *PostgreDatabase) RemoveAllUserPaymentMethods(ctx context.Context) error {
	_, err := db.PgxPool.Exec(
		ctx,
		`delete from payment_methods`,
	)
	return err
}

func (db *PostgreDatabase) GetUserPaymentMethodAccountNumber(ctx context.Context, form *scommerce.UserPaymentMethodForm[UserAccountID], mid uint64) (string, error) {
	var number pgtype.Text
	err := db.PgxPool.QueryRow(
		ctx,
		`select "account_number" from payment_methods where "id" = $1 limit 1`,
		mid,
	).Scan(&number)
	if err != nil {
		return "", err
	}
	if number.Valid {
		if form != nil {
			form.AccountNumber = &number.String
		}
		return number.String, nil
	}
	if form != nil {
		form.AccountNumber = nil
	}
	return "", nil
}

func (db *PostgreDatabase) GetUserPaymentMethodExpiryDate(ctx context.Context, form *scommerce.UserPaymentMethodForm[UserAccountID], mid uint64) (time.Time, error) {
	var date pgtype.Date
	err := db.PgxPool.QueryRow(
		ctx,
		`select "expiry_date" from payment_methods where "id" = $1 limit 1`,
		mid,
	).Scan(&date)
	if err != nil {
		return time.Time{}, err
	}
	if date.Valid {
		if form != nil {
			form.ExpiryDate = &date.Time
		}
		return date.Time, nil
	} else {
		if form != nil {
			form.ExpiryDate = nil
		}
	}
	return time.Time{}, nil
}

func (db *PostgreDatabase) GetUserPaymentMethodPaymentType(ctx context.Context, form *scommerce.UserPaymentMethodForm[UserAccountID], mid uint64, paymentTypeFrom *scommerce.PaymentTypeForm) (uint64, error) {
	var id uint64
	var name string
	err := db.PgxPool.QueryRow(
		ctx,
		`		
			select
				pt.id,
				pt.name
			from payment_methods pm
			join payment_types pt on pm.payment_type_id = pt.id
			where pm.id = $1
		`,
		mid,
	).Scan(&id, &name)
	if err != nil {
		return 0, err
	}
	if paymentTypeFrom != nil {
		paymentTypeFrom.ID = id
		paymentTypeFrom.Name = &name
	}
	if form != nil {
		form.PaymentType = &scommerce.BuiltinPaymentType{
			PaymentTypeForm: scommerce.PaymentTypeForm{
				ID:   id,
				Name: &name,
			},
			DB: db,
		}
	}
	return id, nil
}

func (db *PostgreDatabase) GetUserPaymentMethodProvider(ctx context.Context, form *scommerce.UserPaymentMethodForm[UserAccountID], mid uint64) (string, error) {
	var provider pgtype.Text
	err := db.PgxPool.QueryRow(
		ctx,
		`select "provider" from payment_methods where "id" = $1 limit 1`,
		mid,
	).Scan(&provider)
	if err != nil {
		return "", err
	}
	if provider.Valid {
		if form != nil {
			form.Provider = &provider.String
		}
		return provider.String, nil
	}
	if form != nil {
		form.Provider = nil
	}
	return "", nil
}

func (db *PostgreDatabase) IsUserPaymentMethodDefault(ctx context.Context, form *scommerce.UserPaymentMethodForm[UserAccountID], mid uint64) (bool, error) {
	var result bool
	err := db.PgxPool.QueryRow(
		ctx,
		`select "is_default" from payment_methods where "id" = $1 limit 1`,
		mid,
	).Scan(&result)
	if err != nil {
		return false, err
	}
	if form != nil {
		form.IsDefaultState = &result
	}
	return result, nil
}

func (db *PostgreDatabase) IsUserPaymentMethodExpired(ctx context.Context, form *scommerce.UserPaymentMethodForm[UserAccountID], mid uint64) (bool, error) {
	var result bool
	err := db.PgxPool.QueryRow(
		ctx,
		`select "expiry_date" < current_date as "is_expired" from payment_methods where "id" = $1 limit 1`,
		mid,
	).Scan(&result)
	if err != nil {
		return false, err
	}
	if form != nil {
		form.IsExpiredState = &result
	}
	return result, nil
}

func (db *PostgreDatabase) SetUserPaymentMethodAccountNumber(ctx context.Context, form *scommerce.UserPaymentMethodForm[UserAccountID], mid uint64, number string) error {
	_, err := db.PgxPool.Exec(
		ctx,
		`update payment_methods set "account_number" = $1 where "id" = $2`,
		number,
		mid,
	)
	if err != nil {
		return err
	}
	if form != nil {
		form.AccountNumber = &number
	}
	return nil
}

func (db *PostgreDatabase) SetUserPaymentMethodDefault(ctx context.Context, form *scommerce.UserPaymentMethodForm[UserAccountID], mid uint64, state bool) error {
	tx, err := db.PgxPool.Begin(ctx)
	if err != nil {
		return err
	}
	defer tx.Rollback(ctx)

	_, err = tx.Exec(
		ctx,
		`
			update payment_methods set
				"is_default" = false
			where "user_id" = (
				select "user_id" from payment_methods where "id" = $1 limit 1
			);	
		`,
		mid,
	)
	if err != nil {
		return err
	}

	_, err = tx.Exec(
		ctx,
		`update payment_methods set "is_default" = true where "id" = $1`,
		mid,
	)
	if err != nil {
		return err
	}

	return tx.Commit(ctx)
}

func (db *PostgreDatabase) SetUserPaymentMethodExpiryDate(ctx context.Context, form *scommerce.UserPaymentMethodForm[UserAccountID], mid uint64, date time.Time) error {
	_, err := db.PgxPool.Exec(
		ctx,
		`update payment_methods set "expiry_date" = $1 where "id" = $2`,
		pgtype.Date{
			Valid: true,
			Time:  date,
		},
		mid,
	)
	if err != nil {
		return err
	}
	if form != nil {
		form.ExpiryDate = &date
	}
	return nil
}

func (db *PostgreDatabase) SetUserPaymentMethodPaymentType(ctx context.Context, form *scommerce.UserPaymentMethodForm[UserAccountID], mid uint64, pType uint64) error {
	_, err := db.PgxPool.Exec(
		ctx,
		`update payment_methods set "payment_type_id" = $1 where "id" = $2`,
		pType,
		mid,
	)
	if err != nil {
		return err
	}
	if form != nil {
		if pType != 0 {
			form.PaymentType = &scommerce.BuiltinPaymentType{
				DB: db,
				PaymentTypeForm: scommerce.PaymentTypeForm{
					ID: pType,
				},
			}
		} else {
			form.PaymentType = nil
		}
	}
	return nil
}

func (db *PostgreDatabase) SetUserPaymentMethodProvider(ctx context.Context, form *scommerce.UserPaymentMethodForm[UserAccountID], mid uint64, provider string) error {
	_, err := db.PgxPool.Exec(
		ctx,
		`update payment_methods set "provider" = $1 where "id" = $2`,
		provider,
		mid,
	)
	if err != nil {
		return err
	}
	if form != nil {
		form.Provider = &provider
	}
	return nil
}

func (db *PostgreDatabase) FillUserPaymentMethodWithID(ctx context.Context, mid uint64, paymentMethodForm *scommerce.UserPaymentMethodForm[UserAccountID]) error {
	if paymentMethodForm == nil {
		return errors.New("payment method form is nil")
	}

	var userID UserAccountID
	var paymentTypeID uint64
	var provider pgtype.Text
	var accountNumber pgtype.Text
	var expiryDate pgtype.Date
	var isDefault bool

	err := db.PgxPool.QueryRow(
		ctx,
		`
			select
				"user_id",
				"payment_type_id",
				"provider",
				"account_number",
				"expiry_date",
				"is_default"
			from payment_methods
			where "id" = $1
			limit 1
		`,
		mid,
	).Scan(
		&userID,
		&paymentTypeID,
		&provider,
		&accountNumber,
		&expiryDate,
		&isDefault,
	)
	if err != nil {
		return err
	}

	// Check if payment method expired
	var isExpired bool
	err = db.PgxPool.QueryRow(
		ctx,
		`select "expiry_date" < current_date as "is_expired" from payment_methods where "id" = $1 limit 1`,
		mid,
	).Scan(&isExpired)
	if err != nil {
		return err
	}

	paymentMethodForm.ID = mid
	paymentMethodForm.UserAccountID = userID
	paymentMethodForm.IsDefaultState = &isDefault
	paymentMethodForm.IsExpiredState = &isExpired

	if provider.Valid {
		paymentMethodForm.Provider = &provider.String
	} else {
		paymentMethodForm.Provider = nil
	}

	if accountNumber.Valid {
		paymentMethodForm.AccountNumber = &accountNumber.String
	} else {
		paymentMethodForm.AccountNumber = nil
	}

	if expiryDate.Valid {
		paymentMethodForm.ExpiryDate = &expiryDate.Time
	} else {
		paymentMethodForm.ExpiryDate = nil
	}

	if paymentTypeID != 0 {
		paymentMethodForm.PaymentType = &scommerce.BuiltinPaymentType{
			DB: db,
			PaymentTypeForm: scommerce.PaymentTypeForm{
				ID: paymentTypeID,
			},
		}
	} else {
		paymentMethodForm.PaymentType = nil
	}

	return nil
}
